# 13장 테스트

### 단위 테스트

- 애플리케이션의 최소 컴포넌트를 테스트하는 것.
- 일반적으로 단위 테스트의 범위는 하나의 메서드
- 의존성은 단위 테스트를 하는데 혼란을 줄 수 있다. 단위 테스트의 목표는 개별 컴포넌트의 동작 방식을 테스트하는 것
- 항상 동일한 시나리오를 반복해서 테스트할 수 있어야 한다.
    - 다른 테스트가 깨지면 안됩니다.

Junit을 사용할겁니다.

유효성을 검증할 때 사용하게 됩니다

각 테스트 이전에 어떤 로직을 실행하려면 @BeforeEach를 사용합니다.

각 테스트 이후에 어떤 로직을 실행하려면 @AfterEach를 사용합니다.

@BeforeAll은 각 테스트가 아닌 한 번만 실행하고 싶을 때

@Ignore은 실행하지 않고 지나갈 테스트 메서드와 클래스를 나타낼 때

@RunWith은 테스트 케이스를 실행하는 클래스를 JUnit이 아닌 다른 클래스로 지정하고 싶을 때

Mock 객체를 통해 테스트 환경에 필요한 의존성을 대체할 수 있다. 

Stub은 목 객체가 아니다. Stub은 테스트에서 사용되는 하드코딩된 구현체로 런타임 시에 필요한 동작을 정의할 수 있는 목객체가 재사용 가능한 구조인 경우에 사용된다.

Stub은 애플리케이션의 다양한 부분을 대체하기 위해 작성하는 구현체. Stub에는 실행 중 특정 동작을 Mocking하도록 하드코딩된 로직이 포함되어있다.

대부분의 목 객체 프레임워크가 채택한 접근 방식에는 2가지가 있다.

1. 프록시 기반 방식
    1. 실제 객체를 대신하는 객체. 실제 객체를 모킹한다. 프록시 객체를 만든 후, 해당 프록시 객체를 필요로하는 객체에게 setter 또는 생성자를 사용해 세팅한다. 
    2. 이게 프록시 기반 방식의 본질적인 문제인데, 외부 수단을 통해 의존성을 설정할 수 있어야 한다는 것
    3. 즉, new MyObject()를 호출해 생성된 객체를 모킹할 수 없으므로 메서드 내에서 new MyObject()를 호출하면 안 된다. 이런 점 때문에 스프링과 같은 
2. 클래스 재매핑 방식
    1. JMockit이 이런 방식을 사용해 목 객체 관련 기능을 제공한다. 개발자는 클래스 로더에게 로딩되는 클래스 파일에 대한 참조를 재매핑하도록 지시한다. MyDependency.class라는 파일 명을 가진 MyDependency 클래스가 있지만 이 클래스를 모킹한 MyMock 클래스가 있다고 했을 때, 클래스 로더 내의 MyDependency에서 MyMock.class로의 참조를 재매핑한다. 이렇게 하면 new 연산자를 사용해 만든 객체를 모킹할 수 있다. 이 접근 방식은 말 그대로 어떤 구현체도 클래스 로더에 주입할 수 있기 때문에 프록시 객체 접근 방식보다 더 강력한 기능을 제공한다.

### Mockito

- 프록시 기반의 목 객체 프레임워크
- test의존성에 포함되어 있다.
- 
1. 

- `@ExtendWith(SpringExtenstion.class)`
    - JUnit 5가 제공하는 스프링의 기능을 사용할 수 있게 한다.
- @JdbcTest
    - 데이터 베이스 테스트를 할 때 테스트 관련 기능을 제공한다.
- @ContextConfiguration
    - ApplicationContext를 빌드하는데 필요한 클래스를 제공한다.
    - Bean으로 등록될 수 있어야 한다.
- @SpringBatchTest
    - 스프링 배치를 쉽게 테스트할 수 있는 유틸리티(JobLauncherTestUtils)를 제공한다.
    - JobLauncherTestUtils 인스턴스
    - JobRepositoryTestUTils
    - StepScopeTestExecutionListener, JobScopeTestExecutionListener
- @Transactional(propagation=Propagation.NOT_SUPPORTED)
    - @JdbcTest에 가보면 각 테스트메서드를 트랜잭션으로 래핑하고 메서드 실행 완료시 롤백한다.
    - 일반적인 단위 테스트 시나리오에서는 이게 맞지만, 해당 예제에서는 스프링 배치가 트랜잭션을 관리하면서 다른 트랜잭션으로 래핑하면 오류가 발생한다. 이 애너테이션은 @JdbcTest의 트랜잭션 기능이 동작하지 않게 비활성화 한다.
- @EnableBatchProcessing
    - 스프링 배치는 JobRepository와 연결되어야 하므로.
- MetaDataInstanceFactory는 StepExecution과 JobExecution 인스턴스를 생성하는 유틸리티 클래스. 가져온 결과가 JobRepository에 저장되지 않는다는 점이 JobRepositoryTestUtils와 다르다.
- 위 애너테이션을 적용하면 필요한 것들이 Autowired 된다. JobLauncherTestUtils라든지 DataSource라든지...
- 스텝만 실행해줄수도 있다.

앞선 예제에서는 입력/출력 파일 이름의 주입이나 특정 DB 쿼리에 대한 Criteria가 포함된다. 이럴 때 스프링 배치는 JobExecution이나 StepExecution에서 해당 값을 얻어온다.

Job에서 해당 Step을 실행하지 않는다면 JobExecution도, StepExecution도 가져올 수 없다

TestExecutionListener는 테스트 메서드 실행 전후에 수행돼야 하는 일을 정의하는 API다.

TestExecutionListener를 사용하면 테스트 케이스의 모든 메서드에 원하는 동작을 재사용 가능한 방식으로 바꿀 수 있다.

스프링은 DependencyInjectionTestExecutionListener, DirtiesContextTestExecutionListener, TransactionalTestExecutionListener를 제공한다

스프링 배치는 StepScopeTestExecutionListener, JobScopeTestExecutionListener을 제공한다.

StepScopeTestExecutionListener은 팩토리 메서드를 통해 StepExecution을 가져올 수 있다. 팩토리 메서드인 getStepExecution()은 새로운 StepExecution을 가져오기 위해 각 테스트 메서드 전에 호출된다.

만약 팩토리 메서드가 없다면 스프링 배치는 기본적으로 제공되는 StepExecution을 사용한다.
