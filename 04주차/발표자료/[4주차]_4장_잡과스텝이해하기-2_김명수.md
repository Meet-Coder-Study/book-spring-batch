# 잡과 스텝 이해하기

- [스텝 알아보기](#스텝-알아보기)
  - [태스크릿 스텝(TaskletStep)](#태스크릿-스텝(TaskletStep))
    - [태스크릿 스텝을 만드는 법](#태스크릿-스텝을-만드는-법)
  - [청크 기반 스텝](#청크-기반-스텝)
    - [청크 기반 스텝 구성하기](#청크-기반-스텝-구성하기)
    - [청크 크기 구성하기](#청크-크기-구성하기)
  - [스텝 리스너](#스텝-리스너)
  - [스텝 플로우](#스텝-플로우)
    - [Sequential Flow](#Sequential-Flow)
    - [Conditional Flow](#Conditional-Flow)
    - [Programmatic Flow Decisions](#Programmatic-Flow-Decisions)
- [References](#References)

---  

# 스텝 알아보기

- **잡(Job)**: 전체적인 처리를 정의 / **스텝(Step)**: 잡의 구성 요소를 담당한다.

## 태스크릿 스텝(TaskletStep)

- 간단한 프로시저나 쉘스크립트 등을 호출할 때 사용될 수 있다.
- Tasklet 인터페이스는 하나의 `RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext)` 메소드만 정의되어 있다.
  - `org.springframework.batch.repeat.RepeatStatus`는 `CONTINUABLE`과 `FINISHED` 2가지만 정의되어 있다.
- `RepeatStatus.FINISHED`를 반환할때까지 트랜잭션 범위 내에서 반보적으로 실행한다.
  - `RepeatStatus.CONTINUABLE`는 하나의 Job내에서 해당 Tasklet을 여러번 수행하는 것을 의미한다.

<details>
<summary>:open_book: Transaction in TaskletStep</summary>  

---  

TaskletStep의 전체 흐름을 살펴보기 위해 아래와 같이 `Tasklet` 구현체에 Stack Trace를 출력한다.

```java
private Step repeatableStep() {
  final Tasklet tasklet = (contribution, chunkContext) -> {
      logger.info("Current stack trace\n{}", ThreadUtil.getStackTrace());
      return RepeatStatus.FINISHED;
  };

  return this.stepBuilderFactory.get("repeatableStep")
                                .tasklet(tasklet)
                                .build();
  }
```

```shell
io.spring.batch.taskletexample.BatchConfiguration.lambda$stackTraceLoggingStep$1(BatchConfiguration.java:88)
org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:407)
org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:331)
org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140)
org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:273)
org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82)
org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:375)
org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:215)
org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:145)
org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:258)
org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:208)
org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:152)
org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:413)
org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:136)
org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:320)
org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:149)
```

[org.springframework.batch.core.step.tasklet.TaskletStep::doExecute(StepExecution stepExecution)](https://github.com/spring-projects/spring-batch/blob/4.3.3/spring-batch-core/src/main/java/org/springframework/batch/core/step/tasklet/TaskletStep.java#L247)를 통해  
TaskletStep의 동작 방식을 확인할 수 있다.

1. ExecutionContext에 메타데이터를 추가하고 JobRepository::update를 수행한다.
2. `Semaphore(permits==1)`를 생성한다(?)
3. `StepExection`의 Interrupted 여부를 체크한다.
4. `TransactionTemplate`를 이용하여 현재 트랜잭션을 이용한다(없으면 생성)
5. `ChunkTransactionCallback`를 생성하여 청크 기반의 트랜잭션 처리를 Wrapping 한다.
6. `StepExection`의 Interrupted 여부를 한번 더 체크한다.

```java
protected void doExecute(StepExecution stepExecution) throws Exception {
  stepExecution.getExecutionContext().put(TASKLET_TYPE_KEY, tasklet.getClass().getName());
  stepExecution.getExecutionContext().put(STEP_TYPE_KEY, this.getClass().getName());

  stream.update(stepExecution.getExecutionContext());
  getJobRepository().updateExecutionContext(stepExecution);

  // Shared semaphore per step execution, so other step executions can run
  // in parallel without needing the lock
  final Semaphore semaphore = createSemaphore();

  stepOperations.iterate(new StepContextRepeatCallback(stepExecution) {

      @Override
      public RepeatStatus doInChunkContext(RepeatContext repeatContext, ChunkContext chunkContext)
              throws Exception {

          StepExecution stepExecution = chunkContext.getStepContext().getStepExecution();

          // Before starting a new transaction, check for
          // interruption.
          interruptionPolicy.checkInterrupted(stepExecution);

          RepeatStatus result;
          try {
              result = new TransactionTemplate(transactionManager, transactionAttribute)
              .execute(new ChunkTransactionCallback(chunkContext, semaphore));
          }
          catch (UncheckedTransactionException e) {
              // Allow checked exceptions to be thrown inside callback
              throw (Exception) e.getCause();
          }

          chunkListener.afterChunk(chunkContext);

          // Check for interruption after transaction as well, so that
          // the interrupted exception is correctly propagated up to
          // caller
          interruptionPolicy.checkInterrupted(stepExecution);

          return result == null ? RepeatStatus.FINISHED : result;
      }

  });
}
```  

---  

</details>  

<br />

간단하게 아래와 같이 Tasklet을 정의하여 5번까지는 `RepeatStatus.CONTINUABLE`를 반환해보자.

```java
private Step repeatableStep() {
    final Tasklet tasklet = (contribution, chunkContext) -> {
        BatchConfiguration.this.processed++;
        logger.info("Running tasklet.. processed:{}", BatchConfiguration.this.processed);

        if (BatchConfiguration.this.processed <= 5) {
            return RepeatStatus.CONTINUABLE;
        }

        logger.info("Will return RepeatStatus.FINISHED");
        return RepeatStatus.FINISHED;
    };

    return this.stepBuilderFactory.get("repeatableStep")
                                  .tasklet(tasklet)
                                  .build();
}
```  

<br />

Console log를 통해 하나의 Job에서 총 6번의 `Tasklet`이 수행되었고 `BATCH_STEP_EXECUTION` 테이블의 레코드를 확인해보면  
`Version: 8`, `COMMIT_COUNT: 6`을 확인할 수 있다.

<br />  

```shell
// Console log
//2021-09-05 17:02:55.069  INFO 8660 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=job]] launched with the following parameters: [{run.id=1}]
//2021-09-05 17:02:55.123  INFO 8660 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [repeatableStep]
//2021-09-05 17:02:55.142  INFO 8660 --- [           main] i.s.b.taskletexample.BatchConfiguration  : Running tasklet.. processed:1
//2021-09-05 17:02:55.150  INFO 8660 --- [           main] i.s.b.taskletexample.BatchConfiguration  : Running tasklet.. processed:2
//2021-09-05 17:02:55.158  INFO 8660 --- [           main] i.s.b.taskletexample.BatchConfiguration  : Running tasklet.. processed:3
//2021-09-05 17:02:55.166  INFO 8660 --- [           main] i.s.b.taskletexample.BatchConfiguration  : Running tasklet.. processed:4
//2021-09-05 17:02:55.174  INFO 8660 --- [           main] i.s.b.taskletexample.BatchConfiguration  : Running tasklet.. processed:5
//2021-09-05 17:02:55.182  INFO 8660 --- [           main] i.s.b.taskletexample.BatchConfiguration  : Running tasklet.. processed:6
//2021-09-05 17:02:55.182  INFO 8660 --- [           main] i.s.b.taskletexample.BatchConfiguration  : Will return RepeatStatus.FINISHED

// BATCH_STEP_EXECUTION table
mysql> SELECT * FROM BATCH_STEP_EXECUTION;
+-------------------+---------+----------------+------------------+----------------------------+----------------------------+-----------+--------------+------------+--------------+-------------+-----------------+------------------+--------------------+----------------+-----------+--------------+----------------------------+
| STEP_EXECUTION_ID | VERSION | STEP_NAME      | JOB_EXECUTION_ID | START_TIME                 | END_TIME                   | STATUS    | COMMIT_COUNT | READ_COUNT | FILTER_COUNT | WRITE_COUNT | READ_SKIP_COUNT | WRITE_SKIP_COUNT | PROCESS_SKIP_COUNT | ROLLBACK_COUNT | EXIT_CODE | EXIT_MESSAGE | LAST_UPDATED               |
+-------------------+---------+----------------+------------------+----------------------------+----------------------------+-----------+--------------+------------+--------------+-------------+-----------------+------------------+--------------------+----------------+-----------+--------------+----------------------------+
|                 1 |       8 | repeatableStep |                1 | 2021-09-05 17:02:55.123000 | 2021-09-05 17:02:55.195000 | COMPLETED |            6 |          0 |            0 |           0 |               0 |                0 |                  0 |              0 | COMPLETED |              | 2021-09-05 17:02:55.197000 |
+-------------------+---------+----------------+------------------+----------------------------+----------------------------+-----------+--------------+------------+--------------+-------------+-----------------+------------------+--------------------+----------------+-----------+--------------+----------------------------+
1 row in set (0.00 sec)
```  

<br />

### 태스크릿 스텝을 만드는 법

직접 구현이외에서 Spring batch에서 제공하는 다양한 클래스를 활용할 수 있다.

1. 인터페이스 구현
2. CallableTaskletAdapter
3. MethodInvokingTaskletAdapter
4. SystemCommandTasklet

<br />

**:white_check_mark: Tasklet 인터페이스 구현**

```java
@Bean
public Step step1() {
    return this.stepBuilderFactory.get("step1")
                                  .tasklet((contribution, chunkContext) -> {
                                      logger.info("Hello, World!");
                                      return RepeatStatus.FINISHED;
                                  })
                                  .build();
}
```  

<br />

**:white_check_mark: CallableTaskletAdapter**

`CallableTaskletAdapter`는 `java.util.concurrent.Callable<RepeatStatus>` 인터페이스의 구현체를 구성할 수 있게 해주는 어댑터다.

`java.lang.Runnable` 인터페이스와 유사하지만 `java.util.concurrent.Callable<V>`는 리턴 타입이 있고 예외(Checked Exception)를 바깥으로 던질 수 있다.

<details>
<summary>Sourcecode</summary>  

```java
package org.springframework.batch.core.step.tasklet;

import java.util.concurrent.Callable;

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Adapts a {@link Callable}&lt;{@link RepeatStatus}&gt; to the {@link Tasklet}
 * interface.
 *
 * @author Dave Syer
 *
 */
public class CallableTaskletAdapter implements Tasklet, InitializingBean {

  private Callable<RepeatStatus> callable;

  /**
   * Public setter for the {@link Callable}.
   * @param callable the {@link Callable} to set
   */
  public void setCallable(Callable<RepeatStatus> callable) {
    this.callable = callable;
  }

  /**
   * Assert that the callable is set.
   *
   * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
   */
  @Override
  public void afterPropertiesSet() throws Exception {
    Assert.notNull(callable, "A Callable is required");
  }

  /**
   * Execute the provided Callable and return its {@link RepeatStatus}. Ignores
   * the {@link StepContribution} and the attributes.
   * @see Tasklet#execute(StepContribution, ChunkContext)
   */
  @Nullable
  @Override
  public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
    return callable.call();
  }

}
```
</details>  

**e.g) CallableTaskletAdapter 사용하기**

```java
@Bean
public Callable<RepeatStatus> callableObject() {
    return () -> {
        logger.info("This was executed in another thread");
        return RepeatStatus.FINISHED;
    };
}

@Bean
public CallableTaskletAdapter callableTaskletAdapter() {
    final CallableTaskletAdapter callableTaskletAdapter = new CallableTaskletAdapter();

    callableTaskletAdapter.setCallable(callableObject());

    return callableTaskletAdapter;
}
```  

병렬 관련 처리는 뒷부분에서 확인할 수 있다.

**:white_check_mark: MethodInvokingTaskletAdapter**

스프링 프레임워크가 제공하는 많은 유틸리티 클래스와 유사하다.

만약 배치 잡 내에서 한 번만 실행하고 싶은 로직을 어떤 서비스가 이미 갖고 있다고 가정해보자.

`Tasklet` 인터페이스를 구현해서 해당 서비스를 직접 호출하는 대신 `MethodInvokingTaskletAdapter`를 이용해서 호출할 수 있다.

`setTargetObject`를 설정해주기 때문에 Bean이 아닌 일반 클래스도 사용이 가능하다.

**e.g) MethodInvokingTaskletAdapter 사용하기**

```java
@Bean
public MethodInvokingTaskletAdapter methodInvokingTaskletAdapter() {
    final MethodInvokingTaskletAdapter methodInvokingTaskletAdapter = new MethodInvokingTaskletAdapter();

    methodInvokingTaskletAdapter.setTargetObject(customService);
    methodInvokingTaskletAdapter.setTargetMethod("service");

    return methodInvokingTaskletAdapter;
}

// Job parameter(late-binding)를 메소드 인자로 사용하는 방법
@StepScope
@Bean
public MethodInvokingTaskletAdapter methodInvokingTaskletAdapter2(
        @Value("#{jobParameters['message']}") String message) {
    final MethodInvokingTaskletAdapter methodInvokingTaskletAdapter = new MethodInvokingTaskletAdapter();

    methodInvokingTaskletAdapter.setTargetObject(customService);
    methodInvokingTaskletAdapter.setTargetMethod("service");
    methodInvokingTaskletAdapter.setArguments(new String[] { message });

    return methodInvokingTaskletAdapter;
}
```  

<details>
<summary>:open_book: ExitStatus</summary>  

StepExecution의 테이블에는 아래와 같은 `EXIT_STATUS` 컬럼이 존재한다.

(*전체 스키마는 [resources](https://github.com/spring-projects/spring-batch/tree/main/spring-batch-core/src/main/resources/org/springframework/batch/core) 하위에 존재한다.*)

```shell
mysql> SELECT * FROM BATCH_STEP_EXECUTION;
+-------------------+---------+----------------+------------------+----------------------------+----------------------------+-----------+--------------+------------+--------------+-------------+-----------------+------------------+--------------------+----------------+-----------+--------------+----------------------------+
| STEP_EXECUTION_ID | VERSION | STEP_NAME      | JOB_EXECUTION_ID | START_TIME                 | END_TIME                   | STATUS    | COMMIT_COUNT | READ_COUNT | FILTER_COUNT | WRITE_COUNT | READ_SKIP_COUNT | WRITE_SKIP_COUNT | PROCESS_SKIP_COUNT | ROLLBACK_COUNT | EXIT_CODE | EXIT_MESSAGE | LAST_UPDATED               |
+-------------------+---------+----------------+------------------+----------------------------+----------------------------+-----------+--------------+------------+--------------+-------------+-----------------+------------------+--------------------+----------------+-----------+--------------+----------------------------+
|                 1 |       8 | repeatableStep |                1 | 2021-09-05 17:02:55.123000 | 2021-09-05 17:02:55.195000 | COMPLETED |            6 |          0 |            0 |           0 |               0 |                0 |                  0 |              0 | COMPLETED |              | 2021-09-05 17:02:55.197000 |
+-------------------+---------+----------------+------------------+----------------------------+----------------------------+-----------+--------------+------------+--------------+-------------+-----------------+------------------+--------------------+----------------+-----------+--------------+----------------------------+
1 row in set (0.00 sec)
```  

`MethodInvokingTaskletAdapter`에서 설정한 `TargetObject::TargetMethod`의 반환형을 어떻게 처리하는지 살펴보자.

```java
package org.springframework.batch.core.step.tasklet;

...

public class MethodInvokingTaskletAdapter extends AbstractMethodInvokingDelegator<Object> implements Tasklet {

	@Nullable
	@Override
	public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
		if (getArguments() == null) {
			setArguments(new Object[]{contribution, chunkContext});
		}
		contribution.setExitStatus(mapResult(invokeDelegateMethod()));
		return RepeatStatus.FINISHED;
	}

	protected ExitStatus mapResult(Object result) {
		if (result instanceof ExitStatus) {
			return (ExitStatus) result;
		}
		return ExitStatus.COMPLETED;
	}
}
```  

위의 코드의 `mapResult(Object result)`에서 확인할 수 있듯이 `ExitStatus`로 캐스팅이 가능한 경우에는 해당 결과값을 사용하고 이외에는 `ExitStatus.COMPLETED`를 반환한다.
</details>  

<br />  

**:white_check_mark: SystemCommandTasklet**

비동기로 시스템 명령을 실행할 때 사용한다.

**e.g) SystemCommandTasklet 사용하기**

```java
@Bean
public SystemCommandTasklet systemCommandTasklet() {
    final SystemCommandTasklet tasklet = new SystemCommandTasklet();

    tasklet.setCommand("touch temp.txt");
    tasklet.setTimeout(5000L);
    tasklet.setInterruptOnCancel(true);

    // 명령을 실행 할 디렉터리 설정 ($cd ./.idea 를 수행하는 것과 같다)
    tasklet.setWorkingDirectory("./.idea");
    // 시스템 반환 코드 <-> ExitStatus 값 매핑.(0==ExitStatus.COMPLETED, 그 외 ExitStatus.FAILED)
    tasklet.setSystemProcessExitCodeMapper(touchCodeMapper());
    // 해당 명령 완료 체크 주기
    tasklet.setTerminationCheckInterval(5000L);
    // 별도의 TaskExecutor로 수행. 시스템 명령 시 잡에 Lock 걸리는 현상을 막기 위해 동기식X
    tasklet.setTaskExecutor(new SimpleAsyncTaskExecutor()); 
    tasklet.setEnvironmentParams(new String[] {"JAVA_HOME=/java", "USER_HOME=/Users/batch"});

    return tasklet;
}

@Bean
public SimpleSystemProcessExitCodeMapper touchCodeMapper() {
    return new SimpleSystemProcessExitCodeMapper();
}
```  

<details>
<summary>:open_book: SystemCommandTasklet 내부 코드 보기</summary>  

`SystemCommandTasklet` 코드를 살펴보면 아래와 같이 등록된 `TaskExecutor` 구현체에서

`Runtime.getRuntime().exec(command, environmentParams, workingDirectory)`를 호출하고

`waitFor()` 메소드를 통해 외부 프로세스를 기다리고 있다. 또한 `checkInterval` 값의 주기를 가지고 해당 프로세스 결과를 체크하고 있다.

```java
package org.springframework.batch.core.step.tasklet;

...

public class SystemCommandTasklet extends StepExecutionListenerSupport implements StoppableTasklet, InitializingBean {

    ...

	@Nullable
	@Override
	public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {

		FutureTask<Integer> systemCommandTask = new FutureTask<>(new Callable<Integer>() {

			@Override
			public Integer call() throws Exception {
				Process process = Runtime.getRuntime().exec(command, environmentParams, workingDirectory);
				return process.waitFor();
			}

		});

		long t0 = System.currentTimeMillis();

		taskExecutor.execute(systemCommandTask);

		while (true) {
			Thread.sleep(checkInterval);//moved to the end of the logic

			if(stoppable) {
				JobExecution jobExecution =
						jobExplorer.getJobExecution(chunkContext.getStepContext().getStepExecution().getJobExecutionId());

				if(jobExecution.isStopping()) {
					stopped = true;
				}
			}

			if (systemCommandTask.isDone()) {
				contribution.setExitStatus(systemProcessExitCodeMapper.getExitStatus(systemCommandTask.get()));
				return RepeatStatus.FINISHED;
			}
			else if (System.currentTimeMillis() - t0 > timeout) {
				systemCommandTask.cancel(interruptOnCancel);
				throw new SystemCommandException("Execution of system command did not finish within the timeout");
			}
			else if (execution.isTerminateOnly()) {
				systemCommandTask.cancel(interruptOnCancel);
				throw new JobInterruptedException("Job interrupted while executing system command '" + command + "'");
			}
			else if (stopped) {
				systemCommandTask.cancel(interruptOnCancel);
				contribution.setExitStatus(ExitStatus.STOPPED);
				return RepeatStatus.FINISHED;
			}
		}
	}
    ...
}
```  

[D2 Hello World-Java에서 외부 프로세스를 실행할 때](https://d2.naver.com/helloworld/1113548) 에서 외부 프로세스를 실행할 때 주의해야 할 점에 대한 설명이 있다.

`Runtime.getRuntime().exec()`과 `new ProcessorBuilder(command).start()`를 이용할 경우에 대한 문제를 다루고 있는데

`SystemCommandTasklet`를 사용한다면 한번 다시 참조해도 좋을 것 같다.
</details>  

---  

## 청크 기반 스텝

Spring Batch는 `Chunk-oriented` processing style을 사용한다.  
여기서 `Chunk-oriented processing`은 한 번에 하나의 데이터를 읽고 트랜잭션 바운더리 안에서 데이터를 쓸 청크를 생성하는 것을 말한다.  
청크 기반 스텝은 최소한 2~3개의 주요 컴포넌트(`ItemReader(필수)`, `ItemProcessor(선택)`, `ItemWriter(필수)`)로 구성된다.

![Chunk-oriented Processing](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/chunk-oriented-processing.png)
(출처: [Chunk-oriented Processing](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/chunk-oriented-processing.png))

![Chunk-oriented Processing with Item Processor](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/chunk-oriented-processing-with-item-processor.png)  
(출처: [Chunk-oriented Processing with Item Processor](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/chunk-oriented-processing-with-item-processor.png))

![Sequence diagram](https://terasoluna-batch.github.io/guideline/5.0.0.RELEASE/en/images/Ch05_transaction_TransactionControlChunkModel_commit.png)  
(출처: https://terasoluna-batch.github.io/guideline/5.0.0.RELEASE/en/Ch05_Transaction.html)

- 배치 처리 시작 지점에서 트랜잭션을 시작한다.
- `ItemReader`로 부터 각각의 Item을 읽고 counter를 증가시킨다.(인메모리)
- counter==chunk size 일 때 수집된 아이템 리스트를 `ItemWriter`로 전달한다.
- 트랜잭션을 커밋한다.

---  

### 청크 기반 스텝 구성하기

아래의 예제는 커밋 간격을 10개 아이템으로 설정한 청크 기반 스텝 구성이다.

```java
@Slf4j
@Configuration
@EnableBatchProcessing
@RequiredArgsConstructor
public class BasicConfiguration {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job job() {
        return jobBuilderFactory.get("job")
                                .incrementer(new RunIdIncrementer())
                                .start(step1())
                                .build();
    }

    @Bean
    public Step step1() {
        return stepBuilderFactory.get("step1")
                                 .<String, String>chunk(10)
                                 .reader(itemReader(null))
                                 .writer(itemWriter(null))
                                 .build();
    }

    @Bean
    @StepScope
    public FlatFileItemReader<String> itemReader(
            @Value("#{jobParameters['inputFile']}") Resource inputFile) {
        return new FlatFileItemReaderBuilder<String>()
                .name("itemReader")
                .resource(inputFile)
                .lineMapper(new PassThroughLineMapper())
                .build();
    }

    @Bean
    @StepScope
    public FlatFileItemWriter<String> itemWriter(
            @Value("#{jobParameters['outputFile']}") Resource outputFile) {
        return new FlatFileItemWriterBuilder<String>()
                .name("itemWriter")
                .resource(outputFile)
                .lineAggregator(new PassThroughLineAggregator<>())
                .build();
    }
}
```  

<br />

**:exclamation: 커밋 간격**

커밋 간격을 지정하는 것은 중요하다. 위의 예제에서 청크 사이즈를 10으로 지정했다.
만약 9번째 아이템 처리 후 오류가 발생하면 Write 작업이 이루어지지 않는다.
또한 1과 같은 작은 수로 설정한다면 아이템 기반 처리 방식과 동일하다.  
1건만 이루어지는 문제 뿐만 아니라 트랜잭션 시작과 커밋에 대한 비용, JobRepository 상태 갱신 등 더 많은 비용을 요구한다.  
이상적으로 하나의 트랜잭션에서 가능한 많은 아이템을 처리하는게 바람직하다.

---  

### 청크 크기 구성하기

청크 기반 처리는 스프링 배치의 토대가 되는데, 최대한 활용하기 위해 다양한 구성 방법을 이해하는 것이 중요하다.  
청크 크기를 구성하는 방식은 *정적인 커밋 개수 설정*과 *CompletionPolicy 구현체 사용*이 있다.  
(이외에는 오류 처리와 관련이 있으며 관련 절에서 설명한다.)

**:white_check_mark: 정적인 커밋 개수 설정**

위의 스텝 구성하기와 같이 `StepBuilder`에 정의되어 있는 `<I, O> SimpleStepBuilder<I, O> chunk(int chunkSize)`를 이용하는 것이다.  
여기서 <String, String>은 Input과 Output의 타입이다.

```java
@Bean
public Step step() {
    return stepBuilderFactory.get("step")
                             .<String, String>chunk(10)
                             .reader(itemReader())
                             .writer(itemWriter())
                             .build();
}
```  

커밋 간격을 상수(또는 Config)로 정의할 수 있지만 청크마다 사이즈가 다른 경우도 많다.

<br />  

**:white_check_mark: CompletionPolicy**

- 청크의 완료 여부를 결정할 수 있는 로직을 구현할 수 있게 해준다.
- *org.springframework.batch.repeat.policy.SimpleCompletionPolicy*: 처리된 아이템 개수를 기반으로 임계값(`chunkSize`)에 도달하면 청크 완료로 표시한다.
- *org.springframework.batch.repeat.policy.TimeoutTerminationPolicy*: 설정된 시간을 기반으로 해당 시간이 지나면 청크 완료로 표시한다.

```java
package org.springframework.batch.repeat;

public interface CompletionPolicy {

	boolean isComplete(RepeatContext context, RepeatStatus result);

	boolean isComplete(RepeatContext context);

	RepeatContext start(RepeatContext parent);

	void update(RepeatContext context);
}
```  

<br />  

**SimpleCompletionPolicy(3millis timeout)** 과 **SimpleCompletionPolicy(10개의 청크 사이즈)** 를 조합한 **CompositeCompletionPolicy**

```java
@Bean
public Step chunkStep() {
    return this.stepBuilderFactory.get("chunkStep")
                                  //.<String, String>chunk(5)
                                  .<String, String>chunk(completionPolicy())
                                  .reader(itemReader())
                                  .writer(itemWriter())
                                  .build();
}

@Bean
public CompletionPolicy completionPolicy() {
    final CompositeCompletionPolicy policy = new CompositeCompletionPolicy();

    policy.setPolicies(new CompletionPolicy[] {
        new TimeoutTerminationPolicy(3L),
        new SimpleCompletionPolicy(10)
    });

    return policy;
}
```  

<details>
<summary>:thinking: CompositeCompletionPolicy 살펴보기</summary>  

[CompositeCompletionPolicy](https://github.com/spring-projects/spring-batch/blob/main/spring-batch-infrastructure/src/main/java/org/springframework/batch/repeat/policy/CompositeCompletionPolicy.java)에 등록된 여러 CompletionPolicy 중 어떤 기준으로 청크 완료 여부를 체크하는지 살펴보자.

```java
package org.springframework.batch.repeat.policy;

...

public class CompositeCompletionPolicy implements CompletionPolicy {

    CompletionPolicy[] policies = new CompletionPolicy[0];
    ...
}
```  

위에 코드에서 볼 수 있듯이 `CompletionPolicy` 구현체 배열을 가지고 있다.

다음으로 청크를 생성할 때 호출되는 `start()` 메소드를 살펴보자.

```java
@Override
public RepeatContext start(RepeatContext context) {
    List<RepeatContext> list = new ArrayList<>();
    for (int i = 0; i < policies.length; i++) {
        list.add(policies[i].start(context));
    }
    return new CompositeBatchContext(context, list);
}
```  

등록된 `CompletionPolicy` 구현체 모두 `start()` 메소드를 호출 한 뒤 해당 구현체들을 포함하는 `CompositeBatchContext`를 반환한다.

다음으로 `ItemReader(혹은 ItemProcessor)` 처리 후 호출되는 `update()` 메소드를 살펴보자.

```java
@Override
public void update(RepeatContext context) {
    RepeatContext[] contexts = ((CompositeBatchContext) context).contexts;
    CompletionPolicy[] policies = ((CompositeBatchContext) context).policies;
    for (int i = 0; i < policies.length; i++) {
        policies[i].update(contexts[i]);
    }
    ((RepeatContextSupport) context).increment();
}
```  

마찬가지로 모든 구현체들의 `update()` 메소드를 호출해주고 있다.

마지막으로 청크 생성 완료를 나타내는 `isComplete()` 메소드를 살펴보자.

```java
@Override
public boolean isComplete(RepeatContext context, RepeatStatus result) {
    RepeatContext[] contexts = ((CompositeBatchContext) context).contexts;
    CompletionPolicy[] policies = ((CompositeBatchContext) context).policies;
    for (int i = 0; i < policies.length; i++) {
        if (policies[i].isComplete(contexts[i], result)) {
            return true;
        }
    }
    return false;
}

@Override
public boolean isComplete(RepeatContext context) {
    RepeatContext[] contexts = ((CompositeBatchContext) context).contexts;
    CompletionPolicy[] policies = ((CompositeBatchContext) context).policies;
    for (int i = 0; i < policies.length; i++) {
        if (policies[i].isComplete(contexts[i])) {
            return true;
        }
    }
    return false;
}
```  

등록된 `CompletionPolicy` 구현체 중 하나라도 완료된 경우 `true`를 반환한다.  
즉 등록된 순서에 상관없이 가장 먼저 청크 완료를 나타내는 CompletionPolicy를 기준으로 청크 생성을 완료한다.
</details>  

<details>
<summary>CompletionPolicy 직접 구현하기</summary>  

- start(): Random을 이용하여 `chunkSize` 값을 설정한다.
- update(): `totalProcessed` 값을 1증가 시킨다.
- isComplete(): `totalProcessed`가 `chunkSize`보다 크거나 같은 경우 청크 생성 완료를 반환한다.

```java
@Slf4j
public static class RandomChunkSizePolicy implements CompletionPolicy {

    private int chunkSize;
    private int totalProcessed;
    private Random random = new Random();

    @Override
    public boolean isComplete(RepeatContext context, RepeatStatus result) {
        if (RepeatStatus.FINISHED == result) {
            return true;
        }
        return isComplete(context);
    }

    @Override
    public boolean isComplete(RepeatContext context) {
        return totalProcessed >= chunkSize;
    }

    @Override
    public RepeatContext start(RepeatContext parent) {
        chunkSize = random.nextInt(5);
        totalProcessed = 0;
        logger.info("The chunk size has been set to {}", chunkSize);
        return parent;
    }

    @Override
    public void update(RepeatContext context) {
        this.totalProcessed++;
    }
}
```
</details>  

---  

## 스텝 리스너

Job과 마찬가지로 Step과 관련된 각 컴포넌트 마다 Listener가 존재한다.

`StepExecutionListener`, `StepExecutionListener` 등 모든 리스너는 아래와 같이 등록할 수 있다.

```java
@Bean
public Step step1() {
    return stepBuilderFactory.get("step.chunk.static")
                             .<String, String>chunk(10)
                             .reader(new SimpleItemReader(22))
                             .writer(new SimpleItemWriter())
                             .listener(new LoggingStepExecutionListener())
                             .listener(new LoggingChunkListener())
                             .build();
}
```

<br />

**:white_check_mark: StepExecutionListener**

- 각 스텝의 시작과 끝에서 수행할 수 있다.
- `afterStep` 메소드를 통해서 결과(`ExitStatus`)를 수정할 수 있다.
- `@BeforeStep`, `@AfterStep`의 어노테이션과 동일하다.

<details>
<summary>Specification</summary>  

```java
public interface StepExecutionListener extends StepListener {

    void beforeStep(StepExecution stepExecution);
    ExitStatus afterStep(StepExecution stepExecution);
}
```
</details>  

<br />

**:white_check_mark: StepExecutionListener**

- 각 청크의 시작과 끝에서 수행할 수 있다.
- `@BeforeChunk`의 경우 트랜잭션이 시작되고 호출된다.(reader 호출 전)
- `@AfterChunk`의 경우 트랜잭션이 커밋 된 후 호출된다.(결과를 변경할 수 없다)
- `@BeforeChunk`, `@AfterChunk`, `@AfterChunkError`의 어노테이션과 동일하다.

<details>
<summary>Specification</summary>  

```java
public interface ChunkListener extends StepListener {

    void beforeChunk(ChunkContext context);
    void afterChunk(ChunkContext context);
    void afterChunkError(ChunkContext context);
}
```
</details>  

<br />

**:white_check_mark: ItemWriteListener**

- `@BeforeWrite`, `@AfterWrite`, `@OnWriteError`의 어노테이션과 동일하다.

<details>
<summary>Specification</summary>  

```java
public interface ItemWriteListener<S> extends StepListener {

    void beforeWrite(List<? extends S> items);
    void afterWrite(List<? extends S> items);
    void onWriteError(Exception exception, List<? extends S> items);
}
```
</details>  

<br />

**:white_check_mark: ItemReadListener**

- `@BeforeRead`, `@AfterRead`, `@OnReadError`의 어노테이션과 동일하다.

<details>
<summary>Specification</summary>  

```java
public interface ItemReadListener<T> extends StepListener {

    void beforeRead();
    void afterRead(T item);
    void onReadError(Exception ex);
}
```
</details>  

<br />

**:white_check_mark: SkipListener**

- `@OnSkipInRead`, `@OnSkipInWrite`, `@OnSkipInProcess`의 어노테이션과 동일하다.

<details>
<summary>Specification</summary>  

```java
public interface SkipListener<T,S> extends StepListener {

    void onSkipInRead(Throwable t);
    void onSkipInProcess(T item, Throwable t);
    void onSkipInWrite(S item, Throwable t);
}
```
</details>  

<br />

**:information_source: FYI** : Spring batch docs의 Configuring a Step의 하위 목차를 살펴보면 아래와 같다.

![index of configuration steps](https://user-images.githubusercontent.com/25560203/132129899-eaeff3c3-740c-4762-b671-3017600eab36.png)

Configuring a Step for Restart, Configuring Skip Logic 등 fault tolerance 나 transaction 관련 내용은 뒤에서 나오는 것 같다.

---  

## 스텝 플로우

> 스프링 배치는 기본적으로 각 스텝이 상태(state)와 다음 상태로 이어지는 전이(transition)의 모음을 나타내는 상태머신이다  
> (p.131)

아래의 그림을 살펴보자.

![Spring batch state machine](https://user-images.githubusercontent.com/25560203/132223055-634c26a9-6949-46b6-b23e-983cb456f5f0.png)

각 **상태(State)** 를 나타내는 `Step1`, `Step2`, `Step3`, `Step4`을 정의하였다.

또한 각 스텝의 실행 결과에 따라 다른 상태(State)인 Step으로 **전이(Transition)** 하는 상태머신(StateMachine)을 구성하였다.

`Step1`을 살펴보면 해당 스텝이 *(1)성공한 경우 `Step2`를 수행하는 트랜지션(Transition)* / *(2)실패한 경우 `Step3`을 수행하는 트랜지션(Transition)* 을 정의하고 있다.

즉 `Step`의 실패는 `Job`의 실패는 아니라는 뜻이다. 스프링 배치에서 이러한 Job Flow를 어떻게 제어하는지 살펴보자.

### Sequential Flow

![Sequential Flow](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/sequential-flow.png)  
(출처: [Sequential flow in batch docs](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/step.html#SequentialFlow))

지금까지 구성한 스텝은 모두 **Sequential Flow** 를 의미한다.

1. `StepA`가 성공하면 다음 `StepB`가 수행된다.
2. `StepA`가 실패하면 해당 `Job`은 실패로 종료된다.

많은 경우에 대하여 위의 시나리오로 충분하지만 매우 제한적으로 사용할 수 밖에 없다.

예를들어 `StepA`의 실행 결과(성공/실패 등)에 따라 다른 `StepX`를 수행하고 싶은 경우도 있을 수 있다.

### Conditional Flow

![Conditional Flow](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/conditional-flow.png)  
(출처: [Conditional Flow in batch docs](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/step.html#conditionalFlow))

스프링 배치에서는 해당 Step의 실행 결과에 따른 다른 Step을 수행할 수 있도록 Job을 구성할 수 있다.

**1. Tasklet 정의**

아래와 같이 3가지(pass, success, fail) Tasklet을 정의하자.

```java
@Bean
public Tasklet passTasklet() {
    return (contribution, chunkContext) -> RepeatStatus.FINISHED;
}

@Bean
public Tasklet successTasklet() {
    return (contribution, chunkContext) -> {
        logger.info("Success!");
        return RepeatStatus.FINISHED;
    };
}

@Bean
public Tasklet failTasklet() {
    return (contribution, chunkContext) -> {
        logger.info("Failure!");
        return RepeatStatus.FINISHED;
    };
}
```  

**2. Step 정의**

위에서 정의한 Tasklet을 사용하는 Step을 정의하자.

```java
@Bean
public Step firstStep() {
    return stepBuilderFactory.get("firstStep")
                             .tasklet(passTasklet())
                             .build();
}

@Bean
public Step successStep() {
    return stepBuilderFactory.get("successStep")
                             .tasklet(successTasklet())
                             .build();
}

@Bean
public Step failureStep() {
    return stepBuilderFactory.get("failureStep")
                             .tasklet(failTasklet())
                             .build();
}
```  

**3. Job 정의**

```java
@Bean
public Job job() {
    return jobBuilderFactory.get("conditionalJob")
                            .incrementer(new RunIdIncrementer())
                            .start(firstStep())
                            .on("FAILED").to(failureStep())
                            .from(firstStep()).on("*").to(successStep())
                            .end()
                            .build();
}
```

해당 Job을 실행하면 `firstStep`, `successStep` 스텝이 아래와 같이 실행되는 것을 확인할 수 있다.

```shell
...: Job: [FlowJob: [name=conditionalJob]] launched with the following parameters: [{run.id=1}]
...: Executing step: [firstStep]
...: Step: [firstStep] executed in 44ms
...: Executing step: [successStep]
...: Success!
...: Step: [successStep] executed in 30ms
...: Job: [FlowJob: [name=conditionalJob]] completed with the following parameters: [{run.id=1}] and the following status: [COMPLETED] in 188ms
```  

**4. 코드 설명**

- `start(firstStep())`: `firstStep`으로 시작한다.
- `on("FAILED")`: 현재 Step 결과인 `ExitStatus`를 기준으로 어떤 일을 수행할 지 결정할 수 있도록 구성하게 해준다. 여기서는 `ExistStatus==FAILED`인 경우 다음 스텝을 명시한다.
  - `to(failureStep())`: 다음 Step으로 `failureStep`을 명시한다.
- `from(firstStep())`: 이전에 정의한 Step으로 돌아가 새로운 Path를 정의한다.
  - `on("*").to(successStep())`: 위에서 정의한 `ExistStatus==FAILED`가 아닌 모든 경우(와일드 카드)에 다음 Step으로 `successStep()`을 명시한다.

<br />

`SimpleJobBuilder`에 정의된 `FlowBuilder.TransitionBuilder<FlowJobBuilder> on(String pattern)`를 살펴보자.

해당 빌더의 메소드 `on`는 `String pattern` 이라는 인자를 받고 있다. 여기서 pattern은 Step의 `ExitStatus` 값에 대한 패턴이다.  
패턴은 아래와 같은 2가지 문자를 허용한다.

- `*`: 0개 이상의 문자를 일치(match)시킨다는 것을 의미한다.
  - e.g) C* -> C, COMPLETED, CORRECT
- `?`: 1개의 문자를 일치(match)시킨다는 것을 의미한다.
  - e.g) ?AT -> CAT (O), KAT (O) / THAT (X)

<br />  

<details>
<summary>:open_book: ExitStatus vs BatchStatus</summary>  

Conditional Flow에서 `ExitStatus`와 `BatchStatus`의 차이를 인지하는 것은 중요하다.

`BatchStatus`는 Job 또는 Step의 현재 상태를 식별하는 `JobExecution` 또는 `StepExecution`의 Attribute 이다.  
(`COMPLETED`, `STARTING`, `STARTED`, `STOPPING`, `STOPPED`, `FAILED`, `ABANDONED`, or `UNKNOWN`)

`ExitStatus`는 Job 또는 Step 종료 시 스프링 배치로 반환되는 값이다. 이 값은 다음 어떤 스텝을 수행할지 결정하는 데 사용된다.

</details>  

---  

### Programmatic Flow Decisions

스프링 배치에서는 `JobExecutionDecider` 구현을 통해 프로그래밍적으로 다음에 무엇을 해야할 지 결정할 수 있다.

**1. JobExecutionDecider 구현**

```java
public class RandomDecider implements JobExecutionDecider {

    private final Random random = new Random();

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        if (random.nextBoolean()) {
            return new FlowExecutionStatus(FlowExecutionStatus.COMPLETED.getName());
        }
        return new FlowExecutionStatus(FlowExecutionStatus.FAILED.getName());
    }
}
```  

**2. 해당 Decider를 이용한 Job 구성**

```java
@Bean
public Job job() {
    return jobBuilderFactory.get("programmaticJob")
                            .incrementer(new RunIdIncrementer())
                            .start(firstStep())
                            .next(decider())
                            .from(decider())
                            .on("FAILED").to(failureStep())
                            .from(decider())
                            .on("*").to(successStep())
                            .end()
                            .build();
}
```  

1. `start(firstStep())`: `firstStep()`에 정의한 Step으로 시작한다.
2. `next(decider())`: `firstStep()`이 끝난 뒤 다음 스텝으로 어떻게 할지 `decider()` 를 통해 결정한다.
3. `.from(decider()).on("FAILED").to(failureStep())`: `decider()`의 ExitStatus가 `FAILED` 인 경우 `failureStep()`를 수행한다.
4. `.from(decider()).on("*").to(successStep())`: `decider()`의 ExitStatus가 `FAILED`가 아닌 모든 경우에 대하여`successStep()`를 수행한다.

<details>
<summary>:thinking: Job 구성시 on()을 이용한 TransitionBuilder의 등록 순서는 중요할까?</summary>  

먼저 결론적으로 등록 순서는 중요하지 않다.(현재 분석 기준)

실행 결과를 확인해보기 위해 위에서 작성한 Job 구성을 아래와 같이 변경해보자.

```java
@Bean
public Job job() {
    return jobBuilderFactory.get("programmaticJob")
                            .incrementer(new RunIdIncrementer())
                            .start(firstStep())
                            .next(decider())
                            .from(decider())
                            .on("*").to(successStep())
                            .from(decider())
                            .on("FAILED").to(failureStep())
                            .end()
                            .build();
}
```  

`on()` 메소드를 통해 구성하는 `TransitionBuilder`가 리스트(또는 배열)로 구성되어 있고 등록된 순서로(리스트의 첫번째 인덱스) 실행한다면

`decider()`의 결과에 상관없이 와일드 카드(`*`) 패턴과 매칭이 되기때문에, 항상 `successStep()`을 수행할 것이다.

하지만 실제로 `decider()`가 `FAILED`를 반환한다면 `failureStep()`을 수행한다.

위의 결과를 확인하기 위해 스프링 배치의 [SimpleFlow](https://github.com/spring-projects/spring-batch/blob/main/spring-batch-core/src/main/java/org/springframework/batch/core/job/flow/support/SimpleFlow.java) 상태 머신을 어떻게 구성하는지 간단하게 살펴보자.

`resume(String stateName, FlowExecutor executor)` 메소드를 통해 stateName으로 해당 스텝을 수행한다.

```java
@Override
public FlowExecution resume(String stateName, FlowExecutor executor) throws FlowExecutionException {

    // (1) 상태 이름(stateName)을 통해 State 구현체를 조회한다.
    FlowExecutionStatus status = FlowExecutionStatus.UNKNOWN;
    State state = stateMap.get(stateName);

    // (2) Spring batch log level을 수정해서 상태머신을 확인할 수 있다.
    if (logger.isDebugEnabled()) {
        logger.debug("Resuming state="+stateName+" with status="+status);
    }
    StepExecution stepExecution = null;

    // (3) 현재 상태가 지속 불가능일때까지 상태를 변경한다.
    // Terminate if there are no more states
    while (isFlowContinued(state, status, stepExecution)) {
        stateName = state.getName();

        try {
            if (logger.isDebugEnabled()) {
                logger.debug("Handling state="+stateName);
            }
            // (4) 상태(`state`)를 처리한다(스텝이면 스텝 수행 등)
            status = state.handle(executor);
            stepExecution = executor.getStepExecution();
        }
        catch (FlowExecutionException e) {
            executor.close(new FlowExecution(stateName, status));
            throw e;
        }
        catch (Exception e) {
            executor.close(new FlowExecution(stateName, status));
            throw new FlowExecutionException(String.format("Ended flow=%s at state=%s with exception", name,
                                                                  stateName), e);
        }

        if (logger.isDebugEnabled()) {
            logger.debug("Completed state="+stateName+" with status="+status);
        }
        
        // 다음 상태를 설정한다.
        state = nextState(stateName, status, stepExecution);
    }

    FlowExecution result = new FlowExecution(stateName, status);
    executor.close(result);
    return result;
}
```  

다음으로 다음 상태를 결정하는 `State nextState(String stateName, FlowExecutionStatus status, StepExecution stepExecution)`를 살펴보자.

```java
protected State nextState(String stateName, FlowExecutionStatus status, StepExecution stepExecution) throws FlowExecutionException {
    // (1) 해당 상태 이름(stateName)에 연결된 Transition Set을 조회한다. 여기서 Set 자료구조를 활용하는 것을 알 수 있다.
    // - SimpleFlow의 멤버 필드(transitionMap): private Map<String, Set<StateTransition>> transitionMap = new HashMap<>();
    Set<StateTransition> set = transitionMap.get(stateName);

    if (set == null) {
        throw new FlowExecutionException(String.format("No transitions found in flow=%s for state=%s", getName(),
                                                              stateName));
    }

    String next = null;
    String exitCode = status.getName();

    // (2) 위에서 조회한 Transition Set의 구현체(HashSet, LinkedHashSet, TreeSet 등)에 따라 for loop 순서가 결정된다.
    for (StateTransition stateTransition : set) {
        if (stateTransition.matches(exitCode) || (exitCode.equals("PENDING") && stateTransition.matches("STOPPED"))) {
            if (stateTransition.isEnd()) {
                // End of job
                return null;
            }
            next = stateTransition.getNext();
            break;
        }
    }
    
    ...
}
```  

다음으로 `SimpleFlow`의 멤버필드인 `transitionMap`가 어떻게 구성되는지 `initializeTransitions()` 메소드를 살펴보자.

```java
private void initializeTransitions() {
    ...

    // (1) JobBuilder를 통해 등록 된 StateTransition 리스트 통해 상태 관련 맵(stateMap)을 구성한다.
    // 여기서 stateTransitions의 타입은 List<StateTransition> 이다.
    for (StateTransition stateTransition : stateTransitions) {
        State state = stateTransition.getState();
        String stateName = state.getName();
        stateMap.put(stateName, state);
    }

    // (2) JobBuilder를 통해 등록 된 StateTransition 리스트 통해 전이 관련 맵(transitionMap)을 구성한다.
    for (StateTransition stateTransition : stateTransitions) {

        State state = stateTransition.getState();

        if (!stateTransition.isEnd()) {

            String next = stateTransition.getNext();

            if (!stateMap.containsKey(next)) {
                throw new IllegalArgumentException("Missing state for [" + stateTransition + "]");
            }

        }
        else {
            hasEndStep = true;
        }

        String name = state.getName();

        Set<StateTransition> set = transitionMap.get(name);
        if (set == null) {
            // (3) 여기서 stateTransitionComparator 여부에 따라 LinkedHashSet vs TreeSet을 결정한다.
            // 즉 위에서 살펴본 for (StateTransition stateTransition : set) loop의 순서가 달라진다.
            // stateTransitionComparator == null -> LinkedHashSet 사용 -> Job 구성 transition list 등록 순서대로 수행한다.
            // stateTransitionComparator != null -> TreeSet 사용 -> stateTransitionComparator에 의해 정렬 기준을 선택한다.
            if(stateTransitionComparator == null) {
                set = new LinkedHashSet<>();
            } else {
                set = new TreeSet<>(stateTransitionComparator);
            }

            transitionMap.put(name, set);
        }
        set.add(stateTransition);
    }
    ...
}
```  

마지막으로 멤버 필드인 `Comparator<StateTransition> stateTransitionComparator`의 기본 인스턴스를 살펴보자.

```java
package org.springframework.batch.core.job.flow.support;

import org.springframework.util.StringUtils;

import java.util.Comparator;

/**
 * Sorts by decreasing specificity of pattern, based on just counting
 * wildcards (with * taking precedence over ?). If wildcard counts are equal
 * then falls back to alphabetic comparison. Hence * &gt; foo* &gt; ??? &gt;
 * fo? &gt; foo.
 */
public class DefaultStateTransitionComparator implements Comparator<StateTransition> {
	public static final String STATE_TRANSITION_COMPARATOR = "batch_state_transition_comparator";

	@Override
	public int compare(StateTransition arg0, StateTransition arg1) {
		String value = arg1.getPattern();
		if (arg0.getPattern().equals(value)) {
			return 0;
		}
		int patternCount = StringUtils.countOccurrencesOf(arg0.getPattern(), "*");
		int valueCount = StringUtils.countOccurrencesOf(value, "*");
		if (patternCount > valueCount) {
			return 1;
		}
		if (patternCount < valueCount) {
			return -1;
		}
		patternCount = StringUtils.countOccurrencesOf(arg0.getPattern(), "?");
		valueCount = StringUtils.countOccurrencesOf(value, "?");
		if (patternCount > valueCount) {
			return 1;
		}
		if (patternCount < valueCount) {
			return -1;
		}
		return arg0.getPattern().compareTo(value);
	}
}
```  

위의 코드를 살펴보면 비교 순서는 (1) `*` 갯수 비교 / (2) `?` 갯수 비교 / (3) 문자열 비교 가 된다.

즉 `*` 숫자가 많을수록 뒤로 정렬되어 매치 여부를 마지막에 판단한다.

</details>

---  

## References

- [스프링 배치 완벽 가이드 2/e](https://book.naver.com/bookdb/book_detail.nhn?bid=18990242)
- [Spring batch docs](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/index.html)
- https://terasoluna-batch.github.io/guideline/5.0.0.RELEASE/en/Ch05_Transaction.html
